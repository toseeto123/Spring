	## 중요한 포인트 체크 !!
	Spring에 핵심(객체 지향언어)

스프링은 자바 언어기반의 프레임 워크
자바 언어의 가장큰 특징 - 객체 지향 언어
## 스프링은 객체 지향 언어가 가진 특징을 살려내는 프레임워크
스프링은 좋은 객체지향 에플리케이션을 개발할 수 있게 도와주는 프레임 워크
다형성 + OCP,DIP를 가능하게 지원(클라이언트 코드이 변경 없이 기능확장)

	SpringBoot

Tomcat 등 내장서버 설치 안해도된다(안에 있음)
빌드 구성을 위한 starter 종속성 제공
스프링 3rd parth(외부) 라이브러리 자동 구성
메트릭 ,상태확인 ,외부 구성 같은 프로덕션 준비 기능 제공
관례에 의한 간결한 설정

	Spring과 객체지향

다형성이 가장 중요하다
스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
제어의 역전(loC) , 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다

	## 좋은 객체 지향 설계의 5가지 원칙(SOLID)

SRP(Single responsibility principle)
한클래스는 하나의 책임만 가짐(클수 있고 , 작을 수 있고 , 문맥과 상황에 따라 다르다)
중요한 기준은 변경이다 파급이 적으면 단을 책임 원칙을 잘 따른것 ex)UI변경 , 객체의 생성과 사용을 분리

## OCP(Open / closed principle)
확장에는 열려 있으니 변경에는 닫혀 있어야 한다(다형성을 활용해보자)
인터페이시를 구현한 새로운 클래스를 하나 만들어서 새로운 기능 구현
구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
다형성을 사용했지만 OCP 원칙을 지킬 수 없다.
객체를 생성하고 , 연관 관계를 맺어주는 별도의 조립 , 설정자가 필요하다(Spring이 해줌)

LSP(Liskov substitutie principe)
자동차 액셀은 무조건 앞으로 가라는 기능이다 이를 어길시 리스코프 치환 원칙을 어긴거

ISP(interface segregation principle)
특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다
Ex)자동차 인터페이스 -> 운전 인터페이스 , 정비 인터페이스로 분리
Ex)사용자 클라이언트 -> 운전자 클라이언트 , 정비사 클라이언트 분리
분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
인터페이스가 명확해지고 , 대체 가능성이 높아진다

## DIP(Dependency inversion principle)
추상화에 의존 해야지 , 구체화에 의존하면 안된다 의존성 주입은 이 원칙을 따르는 방법중 하나이다
쉽게 말해 구현 클래스에 의존하지말고 , 인터페이스에 의존하라 (역할의 의존해야지 구현에 의존해선 안된다)
역할(Role)에 의존하게 해야 한다는것 구현체의 의존하면 변경이 어려워진다
!!DIP 의존 관계 역전 원칙 (추상화 구체화 둘다 의존)





	객체 지향 특징

추상화 , 캡슐화 , 상속 , ## 다형성(대체)

	객체 지향 프로그래밍

객체지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 떄문에 대규모 사용
객체들의 모임으로 파악하고자 하는것 각각의 객체는 메세지를 주고받고 데이터를 처리할 수 있다

	유연하고 , 변경이 용이하다?

## 다형성
역할과 - 구현으로 구분하면 세상이 단순해지고 , 유연해지며 변경도 편해진다
장점
-대상의 역할(인터페이스)만 알면 된다.
-구현 대상의 내부 구조를 몰라도 된다.
-구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
-구현 대상 자체를 변경해도 영향을 받지 않는다.
-클라이언트에 영향을 주지 않고 변경 가능

자바 언어의 다형성을 활용
역할 = 인터 페이스
구현 = 인터페이스를 구현할 클래스 , 구현 객체
객체를 설계할 떄 역할과 구현을 명확히 분리
객체 설계시 역할(인터페이스)을 먼저 부여하고 , 그 역할을 수해아는 구현 객체 만들기
!! 인터페이스를 안정적으로 잘 설계하는 것이 중요
혼자 있는 객체는 없다 // 클라이언트 : 요청 , 서버 : 응답 // 수 많은 객체 클라이언트와 객체 서버는 서로 협렵 관계를 가진다

## 다형성의 본질
인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다
!! 클라이언트를 변경하지 않고 , 서버의 구현 기느을 우연하게 변경 할 수 있다.

	@Override

MemberService -> MemverRepository(interface) <- MemoryMemberRepository , JdbcMemberRepository
클라이언트 -> MemberRepository(의존 = 알고있음) <- MemoryMemberRepository , JdbcMemberRepository 2개를 할당 할 수 있음(다형성)


	##정리

모든 설계에 역할과 구현을 분리하자
이상적으로는 모든 설계에 인터페이스를 부여하자(추상화 라는 비용이 발생한다)
기능을 확장할 가능성이 없다면 , 구체 클래스를 직접 사용하고 , 향후 꼭필요할 떄 리팩터링해서 인터페이스를 도입하는 것도 방법이다